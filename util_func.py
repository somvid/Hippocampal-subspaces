import numpy as np
import scipy.stats as stats
from scipy.linalg import orthogonal_procrustes
from numpy.polynomial.legendre import Legendre
import scipy.linalg as la
import pandas as pd

def calcul_ci(data, confidence=0.95, which = 'sem'):
    if which == 'ci':
        a = 1.0 * np.array(data)
        n = len(a)
        m, se = np.mean(a), stats.sem(a)
        h = se * stats.t.ppf((1 + confidence) / 2., n-1)
        return h
    elif which == 'sem':
        a = np.std(data)/np.sqrt(len(data))
        return a
   
def fisher_tau_to_z(tau):
    r = np.sin(0.5*np.pi*tau)
    z = 0.5*np.log((1+r)/(1-r))
    return z

def cos_sim(A, B):
    return np.dot(A, B)/(np.linalg.norm(A)*np.linalg.norm(B))

def translate_mean_to_center(np_set):
    np_set -= np.mean(np_set, 0)
    return np_set

def spatial_normalize(data):
    return data / np.linalg.norm(data)

def rotation_shape(init, data):
    R, s = orthogonal_procrustes(init, data)
    return np.dot(data, R.T) * s

'''
From

Visconti di Oleggio Castello, M., Chauhan, V., Jiahui, G., & Gobbini, M. I. (2020).
An fMRI dataset in response to “The Grand Budapest Hotel”, a socially-rich, naturalistic movie. Scientific Data, 7(1), 383.
'''
def load_confounds(subject, task, run):
    confounds = f'/media/dasom/caee0336-77a9-438c-af2f-7cf5b88293e7/dasom/SM_DATA/social_movie1/derivatives/fmriprep/{subject}/func/{subject}_task-{task}_run-{run}_desc-confounds_timeseries.tsv'
    df = pd.read_csv(confounds, sep='\t')
    return df

def extract_cols(df):
    cols = ['framewise_displacement']
    return df[cols]

def make_poly_regressors(n_samples, order):
    # mean
    X = np.ones((n_samples, 1))
    for d in range(order):
        poly = Legendre.basis(d + 1)
        poly_trend = poly(np.linspace(-1, 1, n_samples))
        X = np.hstack((X, poly_trend[:, None]))
    return X

def clean_data(data, confounds):
    """Clean data by regressing out the following nuisance regressors:
    - six motion parameters and their derivatives
    - global signal
    - framewise displacement
    - six aCompCor components
    - polynomial regressors up to second order
    Parameters
    ----------
    data : array of shape (n_volumes, n_features)
        flattened EPI data
    confounds : pandas Dataframe
        dataframe containing confounds generated by fmriprep
    Returns
    -------
    data_clean : array of shape (n_volumes, n_features)
        denoised data
    """
    # make predictor matrix using confounds computed by fmriprep
    columns = [
        'global_signal',
        'framewise_displacement',
        'trans_x', 'trans_x_derivative1',
        'trans_y', 'trans_y_derivative1',
        'trans_z', 'trans_z_derivative1',
        'rot_x', 'rot_x_derivative1',
        'rot_y', 'rot_y_derivative1',
        'rot_z', 'rot_z_derivative1',
    ]
    # compcor
    n_comp_cor = 6
    columns += [f"a_comp_cor_{c:02d}" for c in range(n_comp_cor)]
    X = confounds[columns].values

    # remove nans
    X[np.isnan(X)] = 0.
    
    # add polynomial components
    n_samples = X.shape[0]
    X = np.hstack((X, make_poly_regressors(n_samples, order=2)))

    # time to clean up
    # center the data first and store the mean
    data_mean = data.mean(0)
    data = data - data_mean
    coef, _, _, _ = la.lstsq(X, data)
    
    # remove trends and add back mean of the data
    data_clean = data - X.dot(coef) + data_mean
    return data_clean